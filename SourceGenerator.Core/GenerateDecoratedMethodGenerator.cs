using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator.Core;

[Generator]
public class GenerateDecoratedMethodGenerator : IIncrementalGenerator
{
    const string generatedNs = nameof(SourceGenerator);
    const string generatedAttrib = nameof(GenerateDecoratedMethodAttribute);

    public void Initialize(IncrementalGeneratorInitializationContext initContext)
    {
        // Retrieve method nodes with the cache attribute
        var nodes = initContext.SyntaxProvider.ForAttributeWithMetadataName(
            $"{generatedNs}.{generatedAttrib}",
            static (syntaxNode, _) => syntaxNode is BaseMethodDeclarationSyntax,
            static (context, _) => Helpers.GetMethodInfo(context, "Decorator")
        );

        // Add the final source for the augmented methods
        initContext.RegisterSourceOutput(
            nodes,
            static (context, node) =>
            {
                var decoratedMethodName = node.MethodName.Replace("Inner", "");
                var decoratedMethodModifiers = node.MethodModifiers.Replace(
                    node.MethodAccessibility,
                    node.DecoratedMethodAccessibility
                );
                var isVoidOrTask = node.ReturnType.Name == "Void" || node.ReturnType.Name == "Task";
                var sourceText = SourceText.From(
                    $$"""
// <autogenerated />
namespace {{node.Namespace}};

{{node.ClassModifiers}} class {{node.ClassName}}{{node.ClassTypeParameters}} {{node.ClassConstraints}}
{
    {{decoratedMethodModifiers}} {{node.ReturnType}} {{decoratedMethodName}}{{node.MethodTypeParameters}}({{node.ParamsDefinitions}}) {{node.MethodConstraints}}
    {
        var decorator = new {{node.DecoratorName}}();
        decorator.OnEntry();
        try {
            {{(isVoidOrTask ? "" : "return")}} {{node.MethodName}}({{node.ParamsCall}});
        }
        catch (Exception ex) {
            decorator.OnException(ex);
        }
        finally {
            decorator.OnExit();
        }
        {{(isVoidOrTask ? "" : "return default;")}}
    }
}
""",
                    Encoding.UTF8
                );

                context.AddSource($"{node.Filename}.g.cs", sourceText);
            }
        );
    }
}
